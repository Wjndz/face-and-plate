import cv2
from easyocr import Reader
from PIL import ImageFont, ImageDraw, Image
import numpy as np
from pymongo import MongoClient
import re
import time
from collections import Counter

# K·∫øt n·ªëi MongoDB
client = MongoClient("mongodb+srv://team2:team21234@cluster0.0tdjk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")
db = client["face_db"]  
collection = db["face_vectors"]  

# C·∫•u h√¨nh EasyOCR
reader = Reader(['en', 'vi'])

# C·∫•u h√¨nh camera
cap = cv2.VideoCapture(1)  
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Font v·∫Ω ch·ªØ
fontpath = "./arial.ttf"
font = ImageFont.truetype(fontpath, 32)
b, g, r, a = 0, 255, 0, 0  

# C√°c bi·∫øn cho vi·ªác theo d√µi k·∫øt qu·∫£ OCR
frame_count = 0
ocr_results = []
scanning = True  # Bi·∫øn ki·ªÉm so√°t qu√©t OCR

# C√°c bi·∫øn cho vi·ªác thu th·∫≠p nhi·ªÅu k·∫øt qu·∫£ OCR
candidate_plates = []      # Danh s√°ch c√°c bi·ªÉn s·ªë ·ª©ng vi√™n
confidence_threshold = 0.6 # Ng∆∞·ª°ng tin c·∫≠y t·ªëi thi·ªÉu
max_candidates = 10        # S·ªë l∆∞·ª£ng ·ª©ng vi√™n t·ªëi ƒëa tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh
min_candidates = 5         # S·ªë l∆∞·ª£ng ·ª©ng vi√™n t·ªëi thi·ªÉu tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh
last_detection_time = 0    # Th·ªùi gian ph√°t hi·ªán bi·ªÉn s·ªë cu·ªëi c√πng

if not cap.isOpened():
    print("Kh√¥ng th·ªÉ m·ªü camera!")
    exit()

# K√≠ch th∆∞·ªõc v√πng qu√©t
zone_w, zone_h = 300, 200

# H√†m chu·∫©n h√≥a bi·ªÉn s·ªë xe
def normalize_plate(text):
    # Lo·∫°i b·ªè c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát kh√¥ng li√™n quan
    text = re.sub(r'[^\w\s\.-]', '', text)
    
    # B·∫£ng ki·ªÉm tra v√† thay th·∫ø cho c√°c k√Ω t·ª± d·ªÖ nh·∫ßm l·∫´n
    confusion_map = {
        '8': 'B',  # Trong v·ªã tr√≠ k√Ω t·ª± c·ªßa bi·ªÉn s·ªë, 8 th∆∞·ªùng l√† B
        '0': 'D',  # 0 th∆∞·ªùng l√† D
        'O': 'D',  # O th∆∞·ªùng l√† D
    
        '5': 'S',  # 5 th∆∞·ªùng l√† S
        'G': '6',  # G th∆∞·ªùng l√† 6 khi ·ªü v·ªã tr√≠ s·ªë
    }
    
    # X·ª≠ l√Ω bi·ªÉn s·ªë xe c√≥ kho·∫£ng tr·∫Øng
    parts = text.split(' ', 1)
    if len(parts) == 2:
        prefix, suffix = parts
        
        # Ph√¢n t√°ch ti·ªÅn t·ªë th√†nh ph·∫ßn s·ªë ƒë·∫ßu v√† ph·∫ßn ch·ªØ
        prefix_match = re.match(r'(\d{2})-?([A-Z0-9]+)', prefix)
        
        if prefix_match:
            num_part, char_part = prefix_match.groups()
            
            # X·ª≠ l√Ω ph·∫ßn ch·ªØ c√°i (thay 8 -> B, v.v.)
            for i, char in enumerate(char_part):
                if char in confusion_map and char.isdigit():  # N·∫øu l√† s·ªë ·ªü v·ªã tr√≠ ch·ªØ c√°i
                    char_part = char_part[:i] + confusion_map[char] + char_part[i+1:]
            
            # T·∫°o l·∫°i ti·ªÅn t·ªë v·ªõi d·∫•u g·∫°ch ngang
            prefix = f"{num_part}-{char_part}"
        
        # Ki·ªÉm tra v√† ƒë·ªãnh d·∫°ng ph·∫ßn h·∫≠u t·ªë
        if suffix.isdigit() and len(suffix) == 5:
            # ƒê·ªãnh d·∫°ng s·ªë 5 ch·ªØ s·ªë th√†nh format xxx.xx
            suffix = f"{suffix[:3]}.{suffix[3:]}"
        
        text = f"{prefix} {suffix}"
    
    # Th√™m d·∫•u "-" n·∫øu thi·∫øu
    text = re.sub(r'(\d{2})([A-Z])', r'\1-\2', text)
    
    # X√≥a kho·∫£ng tr·∫Øng th·ª´a
    text = re.sub(r'\s+', ' ', text).strip()
    
    return text

# H√†m ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa bi·ªÉn s·ªë xe Vi·ªát Nam
def is_valid_vietnamese_plate(plate):
    """Ki·ªÉm tra xem bi·ªÉn s·ªë xe c√≥ tu√¢n theo ƒë·ªãnh d·∫°ng bi·ªÉn s·ªë Vi·ªát Nam kh√¥ng"""
    # Ki·ªÉm tra c√°c m·∫´u bi·ªÉn s·ªë xe ph·ªï bi·∫øn t·∫°i Vi·ªát Nam
    patterns = [
        # Bi·ªÉn s·ªë xe √¥ t√¥: 2 s·ªë ƒë·∫ßu + 1 ch·ªØ + 4-5 s·ªë (vd: 51G-12345)
        r'^\d{2}-[A-Z]\d{4,5}$',
        # Bi·ªÉn s·ªë xe √¥ t√¥ c√≥ 2 ch·ªØ c√°i: 2 s·ªë ƒë·∫ßu + 2 ch·ªØ + 3-5 s·ªë (vd: 30AB-1234)
        r'^\d{2}-[A-Z]{2}\d{3,5}$',
        # Bi·ªÉn s·ªë xe m√°y: 2 s·ªë ƒë·∫ßu + 1 ch·ªØ + 1 s·ªë + d·∫•u ch·∫•m + 2 s·ªë (vd: 59H-2.12)
        r'^\d{2}-[A-Z]\d\.\d{2}$',
        # Bi·ªÉn s·ªë xe m√°y c√≥ 2 ch·ªØ c√°i: 2 s·ªë ƒë·∫ßu + 2 ch·ªØ + 1 s·ªë + d·∫•u ch·∫•m + 2 s·ªë (vd: 59HA-2.12)
        r'^\d{2}-[A-Z]{2}\d\.\d{2}$',
        # Bi·ªÉn s·ªë xe √¥ t√¥ ki·ªÉu m·ªõi v·ªõi format: 2 s·ªë ƒë·∫ßu + 1-2 ch·ªØ c√°i + kho·∫£ng tr·∫Øng + 3-5 s·ªë (vd: 12-B1 168.88)
        r'^\d{2}-[A-Z][A-Z0-9]+ \d{3}(\.\d{2})?$',
    ]
    
    for pattern in patterns:
        if re.match(pattern, plate):
            return True
            
    return False

# H√†m gh√©p bi·ªÉn s·ªë t·ª´ nhi·ªÅu d√≤ng
def combine_plate_lines(text_lines):
    # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£, tr·∫£ v·ªÅ chu·ªói r·ªóng
    if not text_lines:
        return ""
        
    # S·∫Øp x·∫øp c√°c d√≤ng theo t·ªça ƒë·ªô y tƒÉng d·∫ßn (t·ª´ tr√™n xu·ªëng d∆∞·ªõi)
    sorted_lines = sorted(text_lines, key=lambda x: x[0][0][1])
    
    # L·∫•y text t·ª´ c√°c d√≤ng ƒë√£ s·∫Øp x·∫øp
    texts = [line[1] for line in sorted_lines]
    
    # N·∫øu c√≥ 2 d√≤ng tr·ªü l√™n, gh√©p d√≤ng ƒë·∫ßu v√† d√≤ng th·ª© hai
    if len(texts) >= 2:
        top_text = texts[0].strip()
        bottom_text = texts[1].strip()
        
        # Gh√©p 2 d√≤ng v·ªõi kho·∫£ng tr·∫Øng
        combined = f"{top_text} {bottom_text}"
        return combined
    elif len(texts) == 1:
        return texts[0].strip()
    else:
        return ""

# H√†m ti·ªÅn x·ª≠ l√Ω ·∫£nh ƒë·ªÉ c·∫£i thi·ªán OCR
def preprocess_image(image):
    # Chuy·ªÉn sang ·∫£nh x√°m
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    
    # Gi·∫£m nhi·ªÖu v·ªõi GaussianBlur
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    
    # √Åp d·ª•ng ng∆∞·ª°ng th√≠ch ·ª©ng
    thresh = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                  cv2.THRESH_BINARY_INV, 11, 2)
    
    # √Åp d·ª•ng c√°c ph√©p bi·∫øn ƒë·ªïi h√¨nh th√°i h·ªçc
    kernel = np.ones((3, 3), np.uint8)
    opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=1)
    
    # TƒÉng ƒë·ªô t∆∞∆°ng ph·∫£n
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(blur)
    
    return opening, enhanced

# H√†m ch·ªçn bi·ªÉn s·ªë xe ƒë√°ng tin c·∫≠y nh·∫•t
def select_best_plate(candidates):
    if not candidates:
        return None
    
    # ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán c·ªßa m·ªói bi·ªÉn s·ªë
    counter = Counter(candidates)
    
    # S·∫Øp x·∫øp theo s·ªë l·∫ßn xu·∫•t hi·ªán (cao -> th·∫•p)
    sorted_plates = counter.most_common()
    
    # ∆Øu ti√™n bi·ªÉn s·ªë h·ª£p l·ªá theo ƒë·ªãnh d·∫°ng Vi·ªát Nam
    for plate, count in sorted_plates:
        # N·∫øu bi·ªÉn s·ªë h·ª£p l·ªá v√† xu·∫•t hi·ªán √≠t nh·∫•t 3 l·∫ßn
        if is_valid_vietnamese_plate(plate) and count >= 3:
            print(f"üèÅ ƒê√£ ch·ªçn bi·ªÉn s·ªë: {plate} (xu·∫•t hi·ªán {count}/{len(candidates)} l·∫ßn)")
            return plate
    
    # N·∫øu kh√¥ng t√¨m th·∫•y bi·ªÉn s·ªë h·ª£p l·ªá, ch·ªçn bi·ªÉn s·ªë xu·∫•t hi·ªán nhi·ªÅu nh·∫•t
    best_plate, count = sorted_plates[0]
    
    # N·∫øu bi·ªÉn s·ªë xu·∫•t hi·ªán qu√° √≠t, tr·∫£ v·ªÅ None
    if count < 3:  # Y√™u c·∫ßu t·ªëi thi·ªÉu 3 l·∫ßn ph√°t hi·ªán gi·ªëng nhau
        return None
    
    print(f"üèÅ ƒê√£ ch·ªçn bi·ªÉn s·ªë: {best_plate} (xu·∫•t hi·ªán {count}/{len(candidates)} l·∫ßn)")
    return best_plate

while True:
    ret, frame = cap.read()
    if not ret:
        print("Kh√¥ng th·ªÉ ƒë·ªçc khung h√¨nh t·ª´ camera!")
        break

    frame_count += 1
    h_img, w_img = frame.shape[:2]

    # X√°c ƒë·ªãnh v√πng OCR ·ªü gi·ªØa m√†n h√¨nh
    zone_x = (w_img - zone_w) // 2
    zone_y = (h_img - zone_h) // 2

    # V·∫Ω khung v√πng qu√©t
    cv2.rectangle(frame, (zone_x, zone_y), (zone_x + zone_w, zone_y + zone_h), (0, 255, 0), 2)

    # Chuy·ªÉn frame sang PIL ƒë·ªÉ v·∫Ω ch·ªØ
    frame_pil = Image.fromarray(frame)
    draw = ImageDraw.Draw(frame_pil)

    # Ki·ªÉm tra n·∫øu ƒë√£ c√≥ bi·ªÉn s·ªë h·ª£p l·ªá, th√¨ d·ª´ng qu√©t
    if not scanning:
        draw.text((10, 10), "ƒê√£ d·ª´ng qu√©t. Ch·ªù ng∆∞·ªùi d√πng m·ªõi...", font=font, fill=(r, 0, 0, a))
    else:
        # Ch·∫°y OCR m·ªói 5 frame ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô
        if frame_count % 5 == 0:
            # Tr√≠ch xu·∫•t v√πng ROI ƒë·ªÉ OCR (ch·ªâ x·ª≠ l√Ω v√πng quan t√¢m)
            roi = frame[zone_y:zone_y+zone_h, zone_x:zone_x+zone_w]
            
            if roi.size == 0:
                continue
                
            # Ti·ªÅn x·ª≠ l√Ω ·∫£nh ƒë·ªÉ c·∫£i thi·ªán OCR
            processed_roi, enhanced_roi = preprocess_image(roi)
            
            # Hi·ªÉn th·ªã ·∫£nh ti·ªÅn x·ª≠ l√Ω
            cv2.imshow("Preprocessed", processed_roi)
            cv2.imshow("Enhanced", enhanced_roi)
            
            # Th·ª±c hi·ªán OCR tr√™n c√°c phi√™n b·∫£n kh√°c nhau c·ªßa ·∫£nh
            results1 = reader.readtext(roi, detail=1)
            results2 = reader.readtext(processed_roi, detail=1)
            results3 = reader.readtext(enhanced_roi, detail=1)
            
            # K·∫øt h·ª£p k·∫øt qu·∫£, ∆∞u ti√™n k·∫øt qu·∫£ c√≥ ƒë·ªô tin c·∫≠y cao
            ocr_results = results1 + results2 + results3
            
            # L·ªçc k·∫øt qu·∫£, ch·ªâ gi·ªØ l·∫°i c√°c k·∫øt qu·∫£ c√≥ ƒë·ªô tin c·∫≠y cao
            ocr_results = [r for r in ocr_results if r[2] > confidence_threshold]
            
            # S·∫Øp x·∫øp theo ƒë·ªô tin c·∫≠y gi·∫£m d·∫ßn
            ocr_results.sort(key=lambda x: x[2], reverse=True)
            
            # V·∫Ω c√°c bbox v√† text l√™n ·∫£nh ROI
            roi_with_boxes = roi.copy()
            for i, (bbox, text, prob) in enumerate(ocr_results[:3]):  # Ch·ªâ hi·ªÉn th·ªã top 3 k·∫øt qu·∫£
                # L·∫•y t·ªça ƒë·ªô bbox
                topleft = (int(bbox[0][0]), int(bbox[0][1]))
                bottomright = (int(bbox[2][0]), int(bbox[2][1]))
                
                # V·∫Ω bbox
                cv2.rectangle(roi_with_boxes, topleft, bottomright, (0, 255, 0), 2)
                
                # Hi·ªÉn th·ªã text v√† ƒë·ªô tin c·∫≠y b√™n c·∫°nh bbox
                cv2.putText(roi_with_boxes, f"{text} ({prob:.2f})", 
                           (topleft[0], topleft[1] - 5), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
            
            # Hi·ªÉn th·ªã ROI v·ªõi c√°c bbox
            cv2.imshow("ROI with OCR", roi_with_boxes)
        
        # Gh√©p c√°c d√≤ng th√†nh bi·ªÉn s·ªë ho√†n ch·ªânh
        combined_plate = combine_plate_lines(ocr_results)
        
        # Chu·∫©n h√≥a bi·ªÉn s·ªë
        normalized_plate = normalize_plate(combined_plate)
        
        # Hi·ªÉn th·ªã bi·ªÉn s·ªë tr√™n m√†n h√¨nh
        if normalized_plate:
            draw.text((zone_x + 10, zone_y - 40), normalized_plate, font=font, fill=(b, g, r, a))
            
            # Th√™m v√†o danh s√°ch ·ª©ng vi√™n
            candidate_plates.append(normalized_plate)
            last_detection_time = time.time()
            
            # Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng ·ª©ng vi√™n ƒë√£ thu th·∫≠p
            draw.text((10, h_img - 40), f"ƒê√£ c√≥: {len(candidate_plates)}/{max_candidates} ·ª©ng vi√™n", 
                     font=font, fill=(0, g, 0, a))
        
        # Ki·ªÉm tra n·∫øu ƒë√£ thu th·∫≠p ƒë·ªß s·ªë l∆∞·ª£ng ·ª©ng vi√™n ho·∫∑c ƒë√£ h·∫øt th·ªùi gian
        current_time = time.time()
        timeout_condition = (current_time - last_detection_time > 3.0 and len(candidate_plates) >= min_candidates)
        max_candidates_condition = len(candidate_plates) >= max_candidates
        
        if (timeout_condition or max_candidates_condition) and candidate_plates:
            # Ch·ªçn bi·ªÉn s·ªë ƒë√°ng tin c·∫≠y nh·∫•t
            best_plate = select_best_plate(candidate_plates)
            
            if best_plate:
                # Ki·ªÉm tra bi·ªÉn s·ªë h·ª£p l·ªá theo ƒë·ªãnh d·∫°ng Vi·ªát Nam
                if is_valid_vietnamese_plate(best_plate):
                    # T√¨m user m·ªõi nh·∫•t ch∆∞a c√≥ bi·ªÉn s·ªë xe
                    last_entry = collection.find_one({"license_plate": {"$exists": False}}, sort=[("created_at", -1)])
                    
                    if last_entry:
                        # C·∫≠p nh·∫≠t bi·ªÉn s·ªë cho user n√†y
                        collection.update_one({"_id": last_entry["_id"]}, {"$set": {"license_plate": best_plate}})
                        print(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t bi·ªÉn s·ªë '{best_plate}' cho user_id: {last_entry['user_id']}")
                        
                        # In th√¥ng tin user c√≥ bi·ªÉn s·ªë xe
                        user_info = collection.find_one({"_id": last_entry["_id"]})
                        print(f"üìä Th√¥ng tin ƒë·∫ßy ƒë·ªß:")
                        print(f"  üë§ User ID: {user_info['user_id']}")
                        print(f"  üöó Bi·ªÉn s·ªë: {user_info['license_plate']}")
                        print(f"  üïí Th·ªùi gian t·∫°o: {user_info.get('created_at', 'N/A')}")
                        
                        # D·ª´ng qu√©t sau khi c·∫≠p nh·∫≠t th√†nh c√¥ng
                        scanning = False
                    else:
                        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y user m·ªõi n√†o ch∆∞a c√≥ bi·ªÉn s·ªë xe trong database!")
                else:
                    print(f"‚ö†Ô∏è Bi·ªÉn s·ªë '{best_plate}' kh√¥ng h·ª£p l·ªá theo ƒë·ªãnh d·∫°ng Vi·ªát Nam, b·ªè qua!")
            
            # Reset danh s√°ch ·ª©ng vi√™n
            candidate_plates = []

    # Chuy·ªÉn ·∫£nh PIL v·ªÅ OpenCV ƒë·ªÉ hi·ªÉn th·ªã
    frame = cv2.cvtColor(np.array(frame_pil), cv2.COLOR_RGB2BGR)
    cv2.imshow("License Plate Scanner", frame)

    # Ki·ªÉm tra c√≥ user m·ªõi ƒë∆∞·ª£c th√™m v√†o database kh√¥ng
    new_user = collection.find_one({"license_plate": {"$exists": False}}, sort=[("created_at", -1)])
    if new_user and not scanning:
        print(f"üîÑ Ph√°t hi·ªán user_id m·ªõi: {new_user['user_id']} v·ª´a ƒë∆∞·ª£c th√™m v√†o database, ti·∫øp t·ª•c qu√©t...")
        print(f"  üïí Th·ªùi gian t·∫°o: {new_user.get('created_at', 'N/A')}")
        scanning = True  # B·∫≠t l·∫°i OCR n·∫øu c√≥ user m·ªõi
        candidate_plates = []  # Reset danh s√°ch ·ª©ng vi√™n

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()